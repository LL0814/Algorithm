# -*- coding: utf-8 -*-

# 它将待排序的元素分到不同的桶中，对每个桶中的元素进行排序，然后按照桶的顺序依次将元素取出，即可得到有序序列。
# 桶排序的基本思想是将待排序的元素分布到一定数量的桶中，每个桶内部使用其他排序算法（如插入排序、快速排序等）进行排序。
# 然后按照桶的顺序将各个桶中的元素依次取出，即可得到有序序列。
# 需要注意的是，桶排序的效率取决于桶的数量和元素的分布情况。
# 在某些情况下，桶排序可以在线性时间复杂度下完成排序，但在其他情况下，它的时间复杂度可能会退化到O(n^2)。
# 性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序
# 注：k 表示桶的个数


"""
	确定桶的数量的最优解是一个相对复杂的问题，通常需要根据具体的应用场景和数据特征来进行选择。以下是一些常见的方法和考虑因素来确定桶的数量：

	数据分布：观察待排序数据的分布情况。如果数据在整个范围内均匀分布，则可以选择较多的桶数量。如果数据分布不均匀，可以考虑减少桶的数量。

	数据规模：考虑待排序数据的规模。如果数据规模较小，可以选择较少的桶数量。如果数据规模较大，可以选择较多的桶数量。

	内存限制：考虑可用内存的限制。如果内存有限，需要根据可用内存大小来确定桶的数量。较少的桶数量可能需要更少的内存，但可能会导致排序效率降低。

	排序算法：不同的排序算法对桶的数量有不同的要求。某些排序算法对桶的数量有严格的要求，而其他算法则对桶的数量没有太大的限制。因此，选择适合所选排序算法的桶数量。
"""

def bucket_sort(arr):
    # 确定桶的数量
    num_buckets = len(arr)
    
    # 创建桶
    buckets = [[] for _ in range(num_buckets)]
    
    # 将元素分配到桶中
    for num in arr:
        index = num - 1  # 桶的索引从0开始，而数组元素从1开始
        print(index)
        buckets[index].append(num)
    print(buckets)
    # 对每个桶中的元素进行排序
    for bucket in buckets:
        bucket.sort() # 快速排序,插入排序或堆排序
    
    # 按照桶的顺序将元素取出
    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)
    
    return sorted_arr

arr = [4, 6, 5, 7, 3, 1, 2]
sorted_arr = bucket_sort(arr)
print(sorted_arr)  # 输出：[1, 2, 3, 4, 5, 6, 7]
